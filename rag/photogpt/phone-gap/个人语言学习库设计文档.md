# 个人语言学习库 - 设计文档

## 项目概述

**个人语言学习库**是一个基于 RAG（检索增强生成）技术的私人化定制语言学习应用。用户可以通过上传自己的学习笔记、单词本、语法总结、例句等内容，构建专属的个人语言知识库，AI 助手将基于这个知识库提供个性化的学习指导、问答和复习建议。

## 核心特性

### 1. 私人化知识库构建
- **学习笔记上传**：支持文本、Markdown、PDF 等多种格式
- **单词本管理**：添加单词、释义、例句、记忆点
- **语法总结**：记录语法规则、用法示例、易错点
- **例句收集**：保存常用句型、对话示例、文化背景
- **标签分类**：自定义标签，便于管理和检索

### 2. 智能 RAG 检索
- **向量化存储**：所有学习内容自动向量化存储到 Supabase
- **语义检索**：基于语义理解，而非简单关键词匹配
- **上下文关联**：智能关联相关的学习内容
- **用户隔离**：每个用户独立的知识库，数据完全私有

### 3. AI 学习助手
- **个性化问答**：基于个人知识库回答问题
- **学习建议**：根据学习记录推荐复习内容
- **知识关联**：自动发现知识点之间的关联
- **智能纠错**：识别和纠正常见错误

### 4. 学习功能
- **复习提醒**：基于遗忘曲线智能提醒复习
- **学习测试**：自动生成测试题，检验学习效果
- **进度追踪**：可视化学习进度和知识掌握情况
- **知识图谱**：展示知识点之间的关系网络

## 技术架构

### 前端技术栈
- **框架**：Next.js 15 (React 19)
- **UI 组件**：shadcn/ui + Tailwind CSS
- **状态管理**：React Hooks
- **AI SDK**：@ai-sdk/react (流式对话)

### 后端技术栈
- **API 框架**：Next.js API Routes
- **AI 模型**：OpenAI GPT-4o-mini
- **向量数据库**：Supabase (PostgreSQL + pgvector)
- **嵌入模型**：text-embedding-3-small

### 数据流程

```
用户输入内容
    ↓
文本分块处理 (LangChain)
    ↓
向量化 (OpenAI Embedding)
    ↓
存储到 Supabase (用户隔离)
    ↓
用户提问
    ↓
问题向量化
    ↓
RAG 检索相关知识点
    ↓
构建 Prompt
    ↓
LLM 生成回答 (流式输出)
    ↓
返回给前端
```

## 数据库设计

### 表结构

#### 1. users 表
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### 2. learning_chunks 表（学习内容块）
```sql
CREATE TABLE learning_chunks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  vector vector(1536),
  content_type TEXT NOT NULL, -- 'vocabulary', 'grammar', 'note', 'example'
  tags TEXT[],
  metadata JSONB, -- 存储额外信息（如单词、语法规则名称等）
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

#### 3. learning_progress 表（学习进度）
```sql
CREATE TABLE learning_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  chunk_id UUID REFERENCES learning_chunks(id) ON DELETE CASCADE,
  mastery_level INTEGER DEFAULT 0, -- 0-5 掌握程度
  last_reviewed TIMESTAMP,
  next_review TIMESTAMP,
  review_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW()
);
```

### 向量检索函数

```sql
CREATE OR REPLACE FUNCTION get_user_learning_context(
  p_user_id UUID,
  query_vector vector(1536),
  match_threshold FLOAT DEFAULT 0.7,
  match_count INT DEFAULT 5
)
RETURNS TABLE (
  id UUID,
  content TEXT,
  content_type TEXT,
  tags TEXT[],
  metadata JSONB,
  similarity FLOAT
)
LANGUAGE sql
STABLE
AS $$
  SELECT
    lc.id,
    lc.content,
    lc.content_type,
    lc.tags,
    lc.metadata,
    1 - (lc.vector <=> query_vector) as similarity
  FROM learning_chunks lc
  WHERE lc.user_id = p_user_id
    AND 1 - (lc.vector <=> query_vector) > match_threshold
  ORDER BY similarity DESC
  LIMIT match_count;
$$;
```

## API 设计

### 1. 添加学习内容
**POST** `/api/learning/add-content`

**请求体：**
```json
{
  "userId": "user-uuid",
  "content": "Hello world - 你好世界",
  "contentType": "vocabulary",
  "tags": ["基础", "日常用语"],
  "metadata": {
    "word": "Hello",
    "translation": "你好",
    "pronunciation": "/həˈloʊ/",
    "example": "Hello, how are you?"
  }
}
```

**响应：**
```json
{
  "success": true,
  "chunkId": "chunk-uuid"
}
```

### 2. 学习对话
**POST** `/api/learning/chat`

**请求体：**
```json
{
  "userId": "user-uuid",
  "messages": [
    {
      "role": "user",
      "content": "'Hello' 和 'Hi' 有什么区别？"
    }
  ]
}
```

**响应：** 流式输出（SSE）

### 3. 获取学习内容列表
**GET** `/api/learning/content?userId=xxx&type=vocabulary&limit=20`

**响应：**
```json
{
  "contents": [
    {
      "id": "chunk-uuid",
      "content": "Hello world",
      "contentType": "vocabulary",
      "tags": ["基础"],
      "createdAt": "2024-01-01T00:00:00Z"
    }
  ]
}
```

### 4. 更新学习进度
**POST** `/api/learning/progress`

**请求体：**
```json
{
  "userId": "user-uuid",
  "chunkId": "chunk-uuid",
  "masteryLevel": 3
}
```

### 5. 获取复习建议
**GET** `/api/learning/review?userId=xxx`

**响应：**
```json
{
  "reviewItems": [
    {
      "chunkId": "chunk-uuid",
      "content": "Hello world",
      "masteryLevel": 2,
      "daysSinceReview": 5,
      "priority": "high"
    }
  ]
}
```

## 前端页面设计

### 1. 主学习页面 (`/`)
- **学习助手对话区**：基于个人知识库的 AI 问答
- **快速添加区**：快速添加单词、语法、例句
- **学习进度概览**：今日学习、总进度、复习提醒

### 2. 知识库管理页面 (`/library`)
- **内容列表**：按类型、标签筛选
- **添加内容**：支持多种内容类型
- **搜索功能**：语义搜索个人知识库
- **批量操作**：删除、标签管理

### 3. 学习测试页面 (`/quiz`)
- **自动生成测试**：基于知识库生成题目
- **多种题型**：选择题、填空题、翻译题
- **即时反馈**：答题后立即显示答案和解释

### 4. 知识图谱页面 (`/knowledge-map`)
- **可视化展示**：知识点关系网络
- **关联探索**：点击查看相关知识点
- **学习路径**：推荐学习顺序

### 5. 进度统计页面 (`/progress`)
- **学习数据**：总内容数、掌握程度分布
- **时间趋势**：学习曲线图
- **薄弱环节**：需要加强的知识点

## 核心功能实现

### 1. 内容向量化存储

```typescript
// app/api/learning/add-content/route.ts
import { embed } from "ai";
import { createOpenAI } from "@ai-sdk/openai";
import { createClient } from "@supabase/supabase-js";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  baseURL: process.env.OPENAI_API_BASE_URL,
});

const supabase = createClient(
  process.env.SUPABASE_URL ?? "",
  process.env.SUPABASE_KEY ?? ""
);

export async function POST(req: Request) {
  const { userId, content, contentType, tags, metadata } = await req.json();
  
  // 文本分块
  const splitter = new RecursiveCharacterTextSplitter({
    chunkSize: 512,
    chunkOverlap: 100,
  });
  
  const chunks = await splitter.splitText(content);
  
  // 向量化并存储
  for (const chunk of chunks) {
    const { embedding } = await embed({
      model: openai.embedding("text-embedding-3-small"),
      value: chunk,
    });
    
    await supabase.from("learning_chunks").insert({
      user_id: userId,
      content: chunk,
      vector: embedding,
      content_type: contentType,
      tags: tags || [],
      metadata: metadata || {},
    });
  }
  
  return Response.json({ success: true });
}
```

### 2. RAG 检索对话

```typescript
// app/api/learning/chat/route.ts
import { embed, streamText } from "ai";
import { createOpenAI } from "@ai-sdk/openai";
import { createClient } from "@supabase/supabase-js";

export async function POST(req: Request) {
  const { userId, messages } = await req.json();
  const latestMessage = messages.at(-1).content;
  
  // 生成查询向量
  const { embedding } = await embed({
    model: openai.embedding("text-embedding-3-small"),
    value: latestMessage,
  });
  
  // 从用户个人知识库检索
  const { data } = await supabase.rpc("get_user_learning_context", {
    p_user_id: userId,
    query_vector: embedding,
    match_threshold: 0.7,
    match_count: 5,
  });
  
  // 构建上下文
  const context = data.map((item: any) => 
    `[${item.content_type}] ${item.content}\n标签: ${item.tags?.join(", ") || "无"}`
  ).join("\n\n");
  
  // 生成回答
  const result = streamText({
    model: openai("gpt-4o-mini"),
    messages: [
      {
        role: "system",
        content: `你是一个语言学习助手，基于用户个人的学习知识库回答问题。
        
用户知识库内容：
${context}

请基于以上知识库内容回答用户问题。如果知识库中没有相关信息，可以结合通用语言知识回答，但需要说明。
        
回答格式使用 Markdown，可以包含代码块、列表等。`,
      },
      ...messages,
    ],
  });
  
  return result.toDataStreamResponse();
}
```

### 3. 学习进度追踪

```typescript
// 基于遗忘曲线的复习提醒
function calculateNextReview(
  masteryLevel: number,
  lastReviewDate: Date,
  reviewCount: number
): Date {
  // 简化版遗忘曲线算法
  const intervals = [1, 2, 4, 7, 15, 30, 60]; // 天数间隔
  const intervalIndex = Math.min(reviewCount, intervals.length - 1);
  const days = intervals[intervalIndex];
  
  const nextReview = new Date(lastReviewDate);
  nextReview.setDate(nextReview.getDate() + days);
  
  return nextReview;
}
```

## 用户界面组件

### 1. 快速添加组件

```tsx
// components/QuickAdd.tsx
"use client";

export default function QuickAdd({ userId }: { userId: string }) {
  const [content, setContent] = useState("");
  const [contentType, setContentType] = useState("vocabulary");
  
  const handleSubmit = async () => {
    await fetch("/api/learning/add-content", {
      method: "POST",
      body: JSON.stringify({
        userId,
        content,
        contentType,
      }),
    });
  };
  
  return (
    <div className="p-4 border rounded-lg">
      <select value={contentType} onChange={(e) => setContentType(e.target.value)}>
        <option value="vocabulary">单词</option>
        <option value="grammar">语法</option>
        <option value="note">笔记</option>
        <option value="example">例句</option>
      </select>
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="输入学习内容..."
      />
      <button onClick={handleSubmit}>添加</button>
    </div>
  );
}
```

### 2. 学习对话组件

```tsx
// components/LearningChat.tsx
"use client";

import { useChat } from "@ai-sdk/react";

export default function LearningChat({ userId }: { userId: string }) {
  const { messages, input, handleInputChange, handleSubmit } = useChat({
    api: `/api/learning/chat?userId=${userId}`,
  });
  
  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 overflow-y-auto">
        {messages.map((msg) => (
          <div key={msg.id}>
            {msg.role === "user" ? "你" : "助手"}
            {msg.content}
          </div>
        ))}
      </div>
      <form onSubmit={handleSubmit}>
        <input
          value={input}
          onChange={handleInputChange}
          placeholder="询问你的学习问题..."
        />
      </form>
    </div>
  );
}
```

## 部署方案

### 环境变量

```env
# .env.local
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_KEY=your_supabase_key
OPENAI_API_KEY=your_openai_key
OPENAI_API_BASE_URL=your_openai_base_url
```

### Supabase 设置

1. 创建数据库表（见数据库设计部分）
2. 启用 pgvector 扩展
3. 创建向量检索函数
4. 设置 Row Level Security (RLS) 确保用户数据隔离

### 部署步骤

1. **构建项目**
   ```bash
   npm run build
   ```

2. **部署到 Vercel**
   ```bash
   vercel deploy
   ```

3. **配置环境变量**：在 Vercel 后台设置环境变量

## 未来扩展

### 功能扩展
- [ ] 多语言支持（中文、英文、日文等）
- [ ] 语音识别和发音练习
- [ ] 与其他用户分享学习资源
- [ ] 导入 Anki、Quizlet 等学习工具的数据
- [ ] 移动端 App（React Native）

### 技术优化
- [ ] 离线模式支持
- [ ] 批量导入功能
- [ ] 更智能的遗忘曲线算法
- [ ] 知识图谱自动构建
- [ ] 多模态学习（图片、音频）

## 使用场景示例

### 场景 1：添加单词
1. 用户输入："apple - 苹果，水果的一种"
2. 系统自动分类为 "vocabulary"
3. 向量化存储到个人知识库
4. 可以随时通过提问："苹果的英文是什么？" 来检索

### 场景 2：语法学习
1. 用户添加："过去式规则：一般动词加 -ed"
2. 系统存储并关联相关例句
3. 用户提问："walk 的过去式是什么？"
4. AI 基于知识库回答："walk 的过去式是 walked，遵循一般动词加 -ed 的规则"

### 场景 3：复习提醒
1. 系统根据遗忘曲线计算需要复习的内容
2. 推送通知："今天需要复习 5 个单词"
3. 用户进行复习测试
4. 系统更新掌握程度和下次复习时间

## 总结

个人语言学习库通过 RAG 技术实现了真正的个性化学习体验。用户可以：
- ✅ 构建完全私有的知识库
- ✅ 基于个人内容获得智能问答
- ✅ 追踪学习进度和效果
- ✅ 获得个性化的学习建议

这个系统将个人学习数据和 AI 能力完美结合，为语言学习者提供了一个强大的学习工具。

